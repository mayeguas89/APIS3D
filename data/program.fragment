#version 330
#extension GL_NV_shadow_samplers_cube : enable
// Lights
#define MAX_NUMBER_OF_LIGHTS 8
uniform int computeLight;
struct LightSource
{
    int Type;
    vec3 Position;
    vec4 Direction;
    float Attenuation;
    vec3 Color;
    // Para spotLights cos(phi)
    float Cutoff;
    float AmbientContribution;
    float DifuseContribution;
    float SpecularContribution;
};
uniform LightSource Lights[MAX_NUMBER_OF_LIGHTS];

// Color de la luz ambiente
uniform vec3 ambient;
uniform float ambientIntensity;

// Brillo del material
uniform int shininess;
uniform float alpha;

// CameraPosition
uniform vec3 cameraPosition;

// Texture
uniform int hasTexture;
uniform int isCubeMap;
uniform sampler2D colorTexture;
uniform samplerCube cubeTexture;
uniform samplerCube normalTexture;

// Input
in vec4 fColor;
in vec2 fTexture;
in vec4 fNormal;
in vec4 fPos;
in vec3 fTextCube;

// Output
out vec4 FragColor;

void main() {

    vec4 baseColor = fColor;
    
    if(hasTexture == 1)
    {
        if(isCubeMap == 1)
        {
            baseColor = textureCube(cubeTexture, fTextCube);   
        }
        else
        {
            baseColor = texture2D(colorTexture, fTexture);   
        }
    }

    if (computeLight == 1)
    {
        vec3 totalLight = vec3(0.f);
        for (int i=0;i<MAX_NUMBER_OF_LIGHTS;i++)
        {
            vec3 L = vec3(1.f);

            // Directional
            if (Lights[i].Type == 0)
            {
                L = normalize(Lights[i].Direction.xyz);
            }
            // Point light
            else if (Lights[i].Type == 1)
            {
                L = normalize(Lights[i].Position-fPos.xyz);
            }
            // Spot light
            else if (Lights[i].Type == 2)
            {
                // Vector pointing from light to framgent position
                L = normalize(Lights[i].Position-fPos.xyz);
                // Calculate the cos of the angle between the light direction and L
                float cos_theta = max(dot(normalize(Lights[i].Direction.xyz), L), 0.0);
                // If the fragment does not received light from the focal light, give only ambient
                if (cos_theta < Lights[i].Cutoff)
                {
                    vec3 light = ambient * Lights[i].AmbientContribution * ambientIntensity * Lights[i].Color;
                    totalLight += light;
                    continue;
                }
            }

            vec3 N = normalize(fNormal.xyz);

            // Componente difusa
            float diffuse = max(dot(L, N), 0.f);

            // Componente especular
            // Vector reflexion de la luz (espejo)
            vec3 R = normalize(reflect(L, N));

            vec3 EYE = normalize(fPos.xyz - cameraPosition);
            float specular = pow(max(dot(R, EYE), 0.f), shininess);

            vec3 light = ambient * Lights[i].AmbientContribution * ambientIntensity;
            light += diffuse * Lights[i].DifuseContribution;
            light += specular * Lights[i].SpecularContribution;
            light *= Lights[i].Attenuation;
            light *= Lights[i].Color;
            totalLight += light;
        }
        FragColor = vec4(totalLight, 1.0f) * baseColor;
    }
    else
    {
        FragColor = baseColor;
        FragColor.a = FragColor.a * alpha;
    }

}